{
  "name": "weg",
  "tagline": "基于fis3  +  nodejs ＋ swig 前端集成打包框架",
  "body": "#weg\r\n\r\n\r\n基于weg+express+swig的前端和后端集成解决方案。在阅读此文档之前，希望你最好对fis3、swig、express 、mysql有一定的了解。\r\n\r\n\r\n## 目录\r\n\r\n* [特点](#特点)\r\n* [快速开始](#快速开始)\r\n* [目录规范](#目录规范)\r\n - [client 目录](#前端)\r\n    - [public 目录](#page-目录)\r\n        - [component 目录](#组件)\r\n        - [static 目录](#css／js／image公共静态资源)\r\n    - [views 目录](#static-目录)\r\n      - [page 目录](#页面模板)\r\n      - [widget 目录](#组件)\r\n    - [server.conf](#serverconf)\r\n - [server 目录](#后端)\r\n    - [controller 目录](#路由)\r\n    - [lib 目录](#组件扩展)\r\n    - [middleware 目录](#中间件)\r\n    - [model 目录](＃数据模型)\r\n    - [utils 目录](＃工具类)\r\n - [fis-conf.js](#fis配置文件)\r\n - [server.js](#express启动入口)\r\n\r\n## 特点\r\n\r\n* 基于原生fis前端集成方案对前端资源进行打包，相比自定义fis扩展，方便fis组件升级和维护。\r\n* 整合前端和后端，提供一套骨架，并提供基于mysql的运行示例，拿来即可使用，扩展也很方便。\r\n* 模板引擎采用 [swig](http://paularmstrong.github.io/swig/) ，提供易用的 `html`、`head`、`body`、`widget`、`script`、`style` 等扩展标签。基于这些标签后端可以自动完成对页面的性能优化。\r\n* 基于 `widget` 标签，可以轻松实现组件化，同名tpl、 css、js自动关联加载。\r\n\r\n\r\n## 示例截图\r\n\r\n ![image](https://raw.githubusercontent.com/hubcarl/weg-blog/master/client/public/static/images/demo.png)\r\n\r\n\r\n## 快速开始\r\n\r\n如果还没有安装 [node](http://nodejs.org) 请先安装 [node](http://nodejs.org).\r\n\r\n```bash\r\n# 安装 fis 到全局\r\nnpm install -g weg\r\n\r\n# 下载工程.\r\ngit clone https://github.com/hubcarl/weg-blog.git\r\n\r\n\r\n# 进入 weg-blog  目录， release 后就可以预览了。\r\ncd weg-blog\r\n\r\n\r\n#工程运行\r\nweg release -w 文件修改监控\r\nweg server start  --entry app.js 指定node启动入口文件\r\n```\r\n\r\n### page 目录\r\n\r\n所有页面级别的模板文件，放在此目录。此tpl 可以直接在浏览器中预览。比如 page/index.tpl 可以通过 http://127.0.0.1:9000 访问。 需要强调的的是，模板引擎采用的是 [swig](http://paularmstrong.github.io/swig/), 可以采用模板继承机制来实现模板复用。\r\n\r\nlayout.tpl\r\n\r\n```tpl\r\n<!doctype html>\r\n{% html lang=\"en\" framework=\"public/static/js/mod.js\"  %}\r\n    {% head %}\r\n        <meta charset=\"utf-8\">\r\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n        <meta name=\"description\" content=\"\">\r\n        <meta name=\"author\" content=\"\">\r\n        <link rel=\"icon\" href=\"/static/favicon.ico\">\r\n        <title>{{ title }}</title>\r\n\r\n        {% require \"public/static/css/normalize.css\" %}\r\n        {% require \"public/static/css/bootstrap.css\" %}\r\n        {% require \"public/static/css/app.css\" %}\r\n\r\n\r\n    {% endhead %}\r\n\r\n    {% body %}\r\n\r\n        {% widget \"widget/menu/menu.tpl\" %}\r\n\r\n\r\n            {% block beforecontent %}\r\n            {% endblock %}\r\n\r\n            <div class=\"container\">\r\n                {% block content %}\r\n                {% endblock %}\r\n            </div>\r\n    \r\n        {% block aftercontent %}\r\n        {% endblock %}\r\n    \r\n    {% endbody %}\r\n\r\n{% endhtml %}\r\n\r\n```\r\n\r\nnews/index/index.tpl\r\n\r\n```tpl\r\n{% extends 'page/layout.tpl' %}\r\n\r\n{% block content %}\r\n\r\n<div class=\"container smart-container\">\r\n    <div class=\"row row-offcanvas row-offcanvas-right\">\r\n        <div class=\"col-xs-12 col-sm-9\">\r\n            <ul class=\"smart-artiles\" id=\"articleList\">\r\n                {% for item in list %}\r\n                <li>\r\n                    <div class=\"point\">+{{item.hits}}</div>\r\n                    <div class=\"card\">\r\n                        <h2><a href=\"/detail/{{item.id}}\" target=\"_blank\">{{item.title}}</a></h2>\r\n                        <div>\r\n                            <ul class=\"actions\">\r\n                                <li>\r\n                                    <time class=\"timeago\">{{item.createDate}}</time>\r\n                                </li>\r\n                                <li class=\"tauthor\">\r\n                                    <a href=\"#\" target=\"_blank\" class=\"get\">Sky</a>\r\n                                </li>\r\n                                <li><a href=\"#\" class=\"kblink-8007\">+收藏</a></li>\r\n                            </ul>\r\n                        </div>\r\n                    </div>\r\n                </li>\r\n                {% endfor %}\r\n            </ul>\r\n            <div id=\"pagerBottom\" class=\"smart-pager\"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n{% require \"client/views/page/news/index/index.js\" %}\r\n\r\n{% script %}\r\n    console.log('>>>>test>>>>>');\r\n    require('client/views/page/news/index/index.js');\r\n{% endscript %}\r\n\r\n\r\n{% endblock %}\r\n\r\n```\r\n\r\n### static 目录\r\n\r\n用来存放所有静态资源文件，css, js, images ,组件等等。如：\r\n\r\n```\r\n├── css\r\n│   ├── bootstrap-theme.css\r\n│   ├── bootstrap.css\r\n│   └── style.css\r\n└── js\r\n    ├── bootstrap.js\r\n    └── mod.js\r\n```\r\n\r\n### widget 目录\r\n\r\n用来存放各类组件代码。组件分成3类。\r\n\r\n1. 模板类：包含 tpl, 可以选择性的添加 js 和 css 文件，同名的 js 和 css 会被自动加载。\r\n\r\n  模板类文件，可以在模板中通过 widget 标签引用。如\r\n\r\n  ```tpl\r\n  {% widget \"widget/menu/menu.tpl\" %}\r\n  ```\r\n2. js 类： 主要包含 js 文件，放在此目录下的文件一般都会自动被 amd define 包裹，可选择性的添加同名 css 文件，会自动被引用。\r\n\r\n  此类组件，可以在 tpl 或者 js 中通过 require 标签引用。\r\n\r\n  ```tpl\r\n  \r\n    {% require \"client/views/page/news/index/index.js\" %}\r\n\r\n    {% script %}\r\n        console.log('>>>>test>>>>>');\r\n        require('client/views/page/news/index/index.js');\r\n    {% endscript %}\r\n\r\n  ```\r\n3. 纯 css 类：只是包含 css 文件。比如 compass. 同样也是可以通过 require 标签引用。\r\n\r\n### bigpipe\r\n\r\n采用 bigpipe 方案，允许你在渲染页面的时候，提前将框架输出，后续再把耗时的 pagelet 通过 chunk 方式输出到页面，以加速网页渲染。\r\n\r\n- sync 默认就是此模式，直接输出。\r\n- quicking 此类 widget 在输出时，只会输出个壳子，内容由用户自行决定通过 js，另起请求完成填充，包括静态资源加载。\r\n- async 此类 widget 在输出时，也只会输出个壳子，但是内容在 body 输出完后，chunk 输出 js 自动填充。widget 将忽略顺序，谁先准备好，谁先输出。\r\n- pipeline 与 async 基本相同，只是它会严格按顺序输出。\r\n\r\n  {% widget \"widget/header/header.html\" mode=\"pipeline\" id=\"header\" %}\r\n\r\n- 要让 bigpipe 正常运行，需要前端引入 bigpipe.js, 另外 pagelet 为 quickling 模式，是不会自动加载的，需要用户主动去调用 BigPipe.load 方法，才会加载并渲染\r\n\r\n\r\n## 客户端 Pagelet.js\r\n\r\n对外暴露以下几个方法。\r\n\r\n### Pagelet.onPageletArrive\r\n\r\n此方法不需要主动去调用，当 pagelet 输出的时候会自动调用这个方法。不管是 `chunk` 输出的 `pagelet`, 还是靠第二次请求 `quickling` 类型的 `pagelet` 都是靠此方法渲染。\r\n\r\n示例：\r\n\r\n```javascript\r\nPagelet.onPageletArrive({\"container\":\"pages-container\",\"id\":\"spage\",\"html\":\"contact us\",\"js\":[],\"css\":[],\"styles\":[],\"scripts\":[]});\r\n```\r\n\r\n格式说明 \r\n\r\n* `container` 容器\r\n* `id` pagelet id\r\n* `html` 内容\r\n* `js` 外联 js 集合\r\n* `css` 外联 css 集合\r\n* `styles` 内联 css 集合\r\n* `scripts` 内联 js 集合\r\n\r\n### Pagelet.load\r\n\r\n默认 `quickling` 性质的 `pagelet` 不会主动加载，需要用户主动调用此方法，才会开始加载。\r\n\r\n调用方式：\r\n\r\n```javascript  \r\nPagelet.load('pageletId');\r\n\r\nPagelet.load('pageletId1 pageletId2 pagelet Id3');\r\n\r\nPagelet.load({\r\n    pagelets: ['pageletId1', 'pageletId2']\r\n    url: '/other page url',\r\n    cacheID: 'pageletId1&pageletId2', // 设置后不会重复请求Pagelet\r\n    param: 'key1=val1&key2=val2',\r\n    container: dom /* or id or {pageletId1: dom1, pageletId2: dom2}*/,\r\n    cb: function() {\r\n        // excuted when all done.\r\n    }\r\n});\r\n```\r\n\r\n参数说明\r\n\r\n* `pagelets` pagelets 的 id 列表，可以是单个 pagelet， 也可以是多个用空格隔开，或者直接就是一个数组，里面由 pagelet id 组成。\r\n* `url` 页面地址，默认是从当前页面去加载 pagelet，有时你可能需要加载其他页面的 pagelet。\r\n* `param` 附带参数内容。\r\n* `cacheID` pagelet 请求的缓存ID，不设置则请求不会被缓存。\r\n* `container` 指定 pagelet 渲染时的容器。\r\n* `cb` 回调，完成后触发。\r\n\r\n### BigPipe 事件\r\n\r\n* `pageletarrive` 当 pagelet 即将渲染前触发。\r\n* `pageletinsert` pagelet 开始渲染，并已经插入了 css 和 dom 了，还没开始执行脚本时触发。\r\n* `pageletdone` 当 pagelet 全部渲染完成触发。\r\n\r\n事件 API\r\n\r\n* on(type, callback)\r\n* off(type?, callback?)\r\n* once(type, callback)\r\n* trigger(type, args...?)\r\n\r\n### 服务器controller实现\r\n\r\n\r\n```javascript\r\nrouter.get('/async', function (req, res) {\r\n\r\n    //you can assign async data like this  the async content will be rendered in chunk mode\r\n    res.bigpipe.bind('async', function(setter) {\r\n\r\n        // simulate an async progress\r\n        setTimeout(function() {\r\n\r\n            // now set data to the pagelet\r\n            setter(null, {\r\n                title:'bigpipe async test',\r\n                content:'async 此类 widget 在输出时，也只会输出个壳子，但是内容在 body 输出完后，chunk 输出 js 自动填充。widget 将忽略顺序，谁先准备好，谁先输出。'\r\n            });\r\n        }, 2000);\r\n    });\r\n\r\n    res.render('page/test/async/async.tpl', {});\r\n});\r\n```\r\n\r\n### es6 generator yield\r\n\r\n- http://www.alloyteam.com/2015/03/es6-generator-introduction/\r\n- http://www.html-js.com/article/A-day-to-learn-JavaScript-to-replace-the-callback-function-with-ES6-Generator\r\n\r\n### fis-conf.js \r\n\r\n编译配置文件，详情请查看[配置 API](http://fis.baidu.com/docs/api/fis-conf.html)。\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}